{
  "extraction_date": "2026-01-07T23:09:48.430427",
  "repository": "..\\django",
  "total_fossils": 11,
  "fossils": [
    {
      "symbol_name": "authenticate",
      "symbol_type": "function",
      "file_path": "django/contrib/auth/__init__.py",
      "first_commit_sha": "7cc4068c4470876c526830778cbdac2fdfd6dc26",
      "first_commit_date": "2012-10-01T11:04:50",
      "first_commit_message": "Fixed #18616 -- added user_login_fail signal to contrib.auth\n\nThanks to Brad Pitcher for documentation",
      "original_docstring": "If the given credentials are valid, return a User object.",
      "original_source": "def authenticate(**credentials):\n    \"\"\"\n    If the given credentials are valid, return a User object.\n    \"\"\"\n    for backend in get_backends():\n        try:\n            user = backend.authenticate(**credentials)\n        except TypeError:\n            # This backend doesn't accept these credentials as arguments. Try the next one.\n            continue\n        if user is None:\n            continue\n        # Annotate the user object with the path of the backend.\n        user.backend = \"%s.%s\" % (backend.__module__, backend.__class__.__name__)\n        return user\n\n    # The credentials supplied are invalid to all backends, fire signal\n    user_login_failed.send(sender=__name__,\n            credentials=_clean_credentials(credentials))",
      "lines_of_code": 19
    },
    {
      "symbol_name": "login",
      "symbol_type": "function",
      "file_path": "django/contrib/auth/__init__.py",
      "first_commit_sha": "7cc4068c4470876c526830778cbdac2fdfd6dc26",
      "first_commit_date": "2012-10-01T11:04:50",
      "first_commit_message": "Fixed #18616 -- added user_login_fail signal to contrib.auth\n\nThanks to Brad Pitcher for documentation",
      "original_docstring": "Persist a user id and a backend in the request. This way a user doesn't\nhave to reauthenticate on every request. Note that data set during\nthe anonymous session is retained when the user logs in.",
      "original_source": "def login(request, user):\n    \"\"\"\n    Persist a user id and a backend in the request. This way a user doesn't\n    have to reauthenticate on every request. Note that data set during\n    the anonymous session is retained when the user logs in.\n    \"\"\"\n    if user is None:\n        user = request.user\n    # TODO: It would be nice to support different login methods, like signed cookies.\n    if SESSION_KEY in request.session:\n        if request.session[SESSION_KEY] != user.id:\n            # To avoid reusing another user's session, create a new, empty\n            # session if the existing session corresponds to a different\n            # authenticated user.\n            request.session.flush()\n    else:\n        request.session.cycle_key()\n    request.session[SESSION_KEY] = user.id\n    request.session[BACKEND_SESSION_KEY] = user.backend\n    if hasattr(request, 'user'):\n        request.user = user\n    user_logged_in.send(sender=user.__class__, request=request, user=user)",
      "lines_of_code": 22
    },
    {
      "symbol_name": "logout",
      "symbol_type": "function",
      "file_path": "django/contrib/auth/__init__.py",
      "first_commit_sha": "7cc4068c4470876c526830778cbdac2fdfd6dc26",
      "first_commit_date": "2012-10-01T11:04:50",
      "first_commit_message": "Fixed #18616 -- added user_login_fail signal to contrib.auth\n\nThanks to Brad Pitcher for documentation",
      "original_docstring": "Removes the authenticated user's ID from the request and flushes their\nsession data.",
      "original_source": "def logout(request):\n    \"\"\"\n    Removes the authenticated user's ID from the request and flushes their\n    session data.\n    \"\"\"\n    # Dispatch the signal before the user is logged out so the receivers have a\n    # chance to find out *who* logged out.\n    user = getattr(request, 'user', None)\n    if hasattr(user, 'is_authenticated') and not user.is_authenticated():\n        user = None\n    user_logged_out.send(sender=user.__class__, request=request, user=user)\n\n    request.session.flush()\n    if hasattr(request, 'user'):\n        from django.contrib.auth.models import AnonymousUser\n        request.user = AnonymousUser()",
      "lines_of_code": 16
    },
    {
      "symbol_name": "User",
      "symbol_type": "class",
      "file_path": "django/contrib/auth/models.py",
      "first_commit_sha": "bcfaa7351455e76047604c737d9b3f3ae97fb736",
      "first_commit_date": "2007-09-16T01:15:33",
      "first_commit_message": "Fixed #3604 -- django.contrib.auth password checking now uses hashlib if it's available. Thanks, Rob Hudson\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@6318 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
      "original_docstring": "Users within the Django authentication system are represented by this model.\n\nUsername and password are required. Other fields are optional.",
      "original_source": "class User(models.Model):\n    \"\"\"Users within the Django authentication system are represented by this model.\n\n    Username and password are required. Other fields are optional.\n    \"\"\"\n    username = models.CharField(_('username'), max_length=30, unique=True, validator_list=[validators.isAlphaNumeric], help_text=_(\"Required. 30 characters or fewer. Alphanumeric characters only (letters, digits and underscores).\"))\n    first_name = models.CharField(_('first name'), max_length=30, blank=True)\n    last_name = models.CharField(_('last name'), max_length=30, blank=True)\n    email = models.EmailField(_('e-mail address'), blank=True)\n    password = models.CharField(_('password'), max_length=128, help_text=_(\"Use '[algo]$[salt]$[hexdigest]' or use the <a href=\\\"password/\\\">change password form</a>.\"))\n    is_staff = models.BooleanField(_('staff status'), default=False, help_text=_(\"Designates whether the user can log into this admin site.\"))\n    is_active = models.BooleanField(_('active'), default=True, help_text=_(\"Designates whether this user can log into the Django admin. Unselect this instead of deleting accounts.\"))\n    is_superuser = models.BooleanField(_('superuser status'), default=False, help_text=_(\"Designates that this user has all permissions without explicitly assigning them.\"))\n    last_login = models.DateTimeField(_('last login'), default=datetime.datetime.now)\n    date_joined = models.DateTimeField(_('date joined'), default=datetime.datetime.now)\n    groups = models.ManyToManyField(Group, verbose_name=_('groups'), blank=True,\n        help_text=_(\"In addition to the permissions manually assigned, this user will also get all permissions granted to each group he/she is in.\"))\n    user_permissions = models.ManyToManyField(Permission, verbose_name=_('user permissions'), blank=True, filter_interface=models.HORIZONTAL)\n    objects = UserManager()\n\n    class Meta:\n        verbose_name = _('user')\n        verbose_name_plural = _('users')\n        ordering = ('username',)\n\n    class Admin:\n        fields = (\n            (None, {'fields': ('username', 'password')}),\n            (_('Personal info'), {'fields': ('first_name', 'last_name', 'email')}),\n            (_('Permissions'), {'fields': ('is_staff', 'is_active', 'is_superuser', 'user_permissions')}),\n            (_('Important dates'), {'fields': ('last_login', 'date_joined')}),\n            (_('Groups'), {'fields': ('groups',)}),\n        )\n        list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff')\n        list_filter = ('is_staff', 'is_superuser')\n        search_fields = ('username', 'first_name', 'last_name', 'email')\n\n    def __unicode__(self):\n        return self.username\n\n    def get_absolute_url(self):\n        return \"/users/%s/\" % urllib.quote(smart_str(self.username))\n\n    def is_anonymous(self):\n        \"Always returns False. This is a way of comparing User objects to anonymous users.\"\n        return False\n\n    def is_authenticated(self):\n        \"\"\"Always return True. This is a way to tell if the user has been authenticated in templates.\n        \"\"\"\n        return True\n\n    def get_full_name(self):\n        \"Returns the first_name plus the last_name, with a space in between.\"\n        full_name = u'%s %s' % (self.first_name, self.last_name)\n        return full_name.strip()\n\n    def set_password(self, raw_password):\n        import random\n        algo = 'sha1'\n        salt = get_hexdigest(algo, str(random.random()), str(random.random()))[:5]\n        hsh = get_hexdigest(algo, salt, raw_password)\n        self.password = '%s$%s$%s' % (algo, salt, hsh)\n\n    def check_password(self, raw_password):\n        \"\"\"\n        Returns a boolean of whether the raw_password was correct. Handles\n        encryption formats behind the scenes.\n        \"\"\"\n        # Backwards-compatibility check. Older passwords won't include the\n        # algorithm or salt.\n        if '$' not in self.password:\n            is_correct = (self.password == get_hexdigest('md5', '', raw_password))\n            if is_correct:\n                # Convert the password to the new, more secure format.\n                self.set_password(raw_password)\n                self.save()\n            return is_correct\n        return check_password(raw_password, self.password)\n\n    def set_unusable_password(self):\n        # Sets a value that will never be a valid hash\n        self.password = UNUSABLE_PASSWORD\n\n    def has_usable_password(self):\n        return self.password != UNUSABLE_PASSWORD\n\n    def get_group_permissions(self):\n        \"Returns a list of permission strings that this user has through his/her groups.\"\n        if not hasattr(self, '_group_perm_cache'):\n            cursor = connection.cursor()\n            # The SQL below works out to the following, after DB quoting:\n            # cursor.execute(\"\"\"\n            #     SELECT ct.\"app_label\", p.\"codename\"\n            #     FROM \"auth_permission\" p, \"auth_group_permissions\" gp, \"auth_user_groups\" ug, \"django_content_type\" ct\n            #     WHERE p.\"id\" = gp.\"permission_id\"\n            #         AND gp.\"group_id\" = ug.\"group_id\"\n            #         AND ct.\"id\" = p.\"content_type_id\"\n            #         AND ug.\"user_id\" = %s, [self.id])\n            qn = connection.ops.quote_name\n            sql = \"\"\"\n                SELECT ct.%s, p.%s\n                FROM %s p, %s gp, %s ug, %s ct\n                WHERE p.%s = gp.%s\n                    AND gp.%s = ug.%s\n                    AND ct.%s = p.%s\n                    AND ug.%s = %%s\"\"\" % (\n                qn('app_label'), qn('codename'),\n                qn('auth_permission'), qn('auth_group_permissions'),\n                qn('auth_user_groups'), qn('django_content_type'),\n                qn('id'), qn('permission_id'),\n                qn('group_id'), qn('group_id'),\n                qn('id'), qn('content_type_id'),\n                qn('user_id'),)\n            cursor.execute(sql, [self.id])\n            self._group_perm_cache = set([\"%s.%s\" % (row[0], row[1]) for row in cursor.fetchall()])\n        return self._group_perm_cache\n\n    def get_all_permissions(self):\n        if not hasattr(self, '_perm_cache'):\n            self._perm_cache = set([u\"%s.%s\" % (p.content_type.app_label, p.codename) for p in self.user_permissions.select_related()])\n            self._perm_cache.update(self.get_group_permissions())\n        return self._perm_cache\n\n    def has_perm(self, perm):\n        \"Returns True if the user has the specified permission.\"\n        if not self.is_active:\n            return False\n        if self.is_superuser:\n            return True\n        return perm in self.get_all_permissions()\n\n    def has_perms(self, perm_list):\n        \"Returns True if the user has each of the specified permissions.\"\n        for perm in perm_list:\n            if not self.has_perm(perm):\n                return False\n        return True\n\n    def has_module_perms(self, app_label):\n        \"Returns True if the user has any permissions in the given app label.\"\n        if not self.is_active:\n            return False\n        if self.is_superuser:\n            return True\n        return bool(len([p for p in self.get_all_permissions() if p[:p.index('.')] == app_label]))\n\n    def get_and_delete_messages(self):\n        messages = []\n        for m in self.message_set.all():\n            messages.append(m.message)\n            m.delete()\n        return messages\n\n    def email_user(self, subject, message, from_email=None):\n        \"Sends an e-mail to this User.\"\n        from django.core.mail import send_mail\n        send_mail(subject, message, from_email, [self.email])\n\n    def get_profile(self):\n        \"\"\"\n        Returns site-specific profile for this user. Raises\n        SiteProfileNotAvailable if this site does not allow profiles.\n        \"\"\"\n        if not hasattr(self, '_profile_cache'):\n            from django.conf import settings\n            if not settings.AUTH_PROFILE_MODULE:\n                raise SiteProfileNotAvailable\n            try:\n                app_label, model_name = settings.AUTH_PROFILE_MODULE.split('.')\n                model = models.get_model(app_label, model_name)\n                self._profile_cache = model._default_manager.get(user__id__exact=self.id)\n            except (ImportError, ImproperlyConfigured):\n                raise SiteProfileNotAvailable\n        return self._profile_cache",
      "lines_of_code": 175
    },
    {
      "symbol_name": "AbstractUser",
      "symbol_type": "class",
      "file_path": "django/contrib/auth/models.py",
      "first_commit_sha": "c433fcb3fb34fccd69782979f0e7cd5f2d4a4893",
      "first_commit_date": "2012-10-13T09:14:50",
      "first_commit_message": "Fixed #19077, #19079 -- Made USERNAME_FIELD a required field, and modified UserAdmin to match.",
      "original_docstring": "An abstract base class implementing a fully featured User model with\nadmin-compliant permissions.\n\nUsername, password and email are required. Other fields are optional.",
      "original_source": "class AbstractUser(AbstractBaseUser):\n    \"\"\"\n    An abstract base class implementing a fully featured User model with\n    admin-compliant permissions.\n\n    Username, password and email are required. Other fields are optional.\n    \"\"\"\n    username = models.CharField(_('username'), max_length=30, unique=True,\n        help_text=_('Required. 30 characters or fewer. Letters, numbers and '\n                    '@/./+/-/_ characters'),\n        validators=[\n            validators.RegexValidator(re.compile('^[\\w.@+-]+$'), _('Enter a valid username.'), 'invalid')\n        ])\n    first_name = models.CharField(_('first name'), max_length=30, blank=True)\n    last_name = models.CharField(_('last name'), max_length=30, blank=True)\n    email = models.EmailField(_('email address'), blank=True)\n    is_staff = models.BooleanField(_('staff status'), default=False,\n        help_text=_('Designates whether the user can log into this admin '\n                    'site.'))\n    is_active = models.BooleanField(_('active'), default=True,\n        help_text=_('Designates whether this user should be treated as '\n                    'active. Unselect this instead of deleting accounts.'))\n    is_superuser = models.BooleanField(_('superuser status'), default=False,\n        help_text=_('Designates that this user has all permissions without '\n                    'explicitly assigning them.'))\n    date_joined = models.DateTimeField(_('date joined'), default=timezone.now)\n    groups = models.ManyToManyField(Group, verbose_name=_('groups'),\n        blank=True, help_text=_('The groups this user belongs to. A user will '\n                                'get all permissions granted to each of '\n                                'his/her group.'))\n    user_permissions = models.ManyToManyField(Permission,\n        verbose_name=_('user permissions'), blank=True,\n        help_text='Specific permissions for this user.')\n\n    objects = UserManager()\n\n    USERNAME_FIELD = 'username'\n    REQUIRED_FIELDS = ['email']\n\n    class Meta:\n        verbose_name = _('user')\n        verbose_name_plural = _('users')\n        abstract = True\n\n    def get_absolute_url(self):\n        return \"/users/%s/\" % urlquote(self.username)\n\n    def get_full_name(self):\n        \"\"\"\n        Returns the first_name plus the last_name, with a space in between.\n        \"\"\"\n        full_name = '%s %s' % (self.first_name, self.last_name)\n        return full_name.strip()\n\n    def get_short_name(self):\n        \"Returns the short name for the user.\"\n        return self.first_name\n\n    def get_group_permissions(self, obj=None):\n        \"\"\"\n        Returns a list of permission strings that this user has through his/her\n        groups. This method queries all available auth backends. If an object\n        is passed in, only permissions matching this object are returned.\n        \"\"\"\n        permissions = set()\n        for backend in auth.get_backends():\n            if hasattr(backend, \"get_group_permissions\"):\n                if obj is not None:\n                    permissions.update(backend.get_group_permissions(self,\n                                                                     obj))\n                else:\n                    permissions.update(backend.get_group_permissions(self))\n        return permissions\n\n    def get_all_permissions(self, obj=None):\n        return _user_get_all_permissions(self, obj)\n\n    def has_perm(self, perm, obj=None):\n        \"\"\"\n        Returns True if the user has the specified permission. This method\n        queries all available auth backends, but returns immediately if any\n        backend returns True. Thus, a user who has permission from a single\n        auth backend is assumed to have permission in general. If an object is\n        provided, permissions for this specific object are checked.\n        \"\"\"\n\n        # Active superusers have all permissions.\n        if self.is_active and self.is_superuser:\n            return True\n\n        # Otherwise we need to check the backends.\n        return _user_has_perm(self, perm, obj)\n\n    def has_perms(self, perm_list, obj=None):\n        \"\"\"\n        Returns True if the user has each of the specified permissions. If\n        object is passed, it checks if the user has all required perms for this\n        object.\n        \"\"\"\n        for perm in perm_list:\n            if not self.has_perm(perm, obj):\n                return False\n        return True\n\n    def has_module_perms(self, app_label):\n        \"\"\"\n        Returns True if the user has any permissions in the given app label.\n        Uses pretty much the same logic as has_perm, above.\n        \"\"\"\n        # Active superusers have all permissions.\n        if self.is_active and self.is_superuser:\n            return True\n\n        return _user_has_module_perms(self, app_label)\n\n    def email_user(self, subject, message, from_email=None):\n        \"\"\"\n        Sends an email to this User.\n        \"\"\"\n        send_mail(subject, message, from_email, [self.email])\n\n    def get_profile(self):\n        \"\"\"\n        Returns site-specific profile for this user. Raises\n        SiteProfileNotAvailable if this site does not allow profiles.\n        \"\"\"\n        warnings.warn(\"The use of AUTH_PROFILE_MODULE to define user profiles has been deprecated.\",\n            PendingDeprecationWarning)\n        if not hasattr(self, '_profile_cache'):\n            from django.conf import settings\n            if not getattr(settings, 'AUTH_PROFILE_MODULE', False):\n                raise SiteProfileNotAvailable(\n                    'You need to set AUTH_PROFILE_MODULE in your project '\n                    'settings')\n            try:\n                app_label, model_name = settings.AUTH_PROFILE_MODULE.split('.')\n            except ValueError:\n                raise SiteProfileNotAvailable(\n                    'app_label and model_name should be separated by a dot in '\n                    'the AUTH_PROFILE_MODULE setting')\n            try:\n                model = models.get_model(app_label, model_name)\n                if model is None:\n                    raise SiteProfileNotAvailable(\n                        'Unable to load the profile model, check '\n                        'AUTH_PROFILE_MODULE in your project settings')\n                self._profile_cache = model._default_manager.using(\n                                   self._state.db).get(user__id__exact=self.id)\n                self._profile_cache.user = self\n            except (ImportError, ImproperlyConfigured):\n                raise SiteProfileNotAvailable\n        return self._profile_cache",
      "lines_of_code": 152
    },
    {
      "symbol_name": "UserManager",
      "symbol_type": "class",
      "file_path": "django/contrib/auth/models.py",
      "first_commit_sha": "bcfaa7351455e76047604c737d9b3f3ae97fb736",
      "first_commit_date": "2007-09-16T01:15:33",
      "first_commit_message": "Fixed #3604 -- django.contrib.auth password checking now uses hashlib if it's available. Thanks, Rob Hudson\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@6318 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
      "original_docstring": null,
      "original_source": "class UserManager(models.Manager):\n    def create_user(self, username, email, password=None):\n        \"Creates and saves a User with the given username, e-mail and password.\"\n        now = datetime.datetime.now()\n        user = self.model(None, username, '', '', email.strip().lower(), 'placeholder', False, True, False, now, now)\n        if password:\n            user.set_password(password)\n        else:\n            user.set_unusable_password()\n        user.save()\n        return user\n\n    def make_random_password(self, length=10, allowed_chars='abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789'):\n        \"Generates a random password with the given length and given allowed_chars\"\n        # Note that default value of allowed_chars does not have \"I\" or letters\n        # that look like it -- just to avoid confusion.\n        from random import choice\n        return ''.join([choice(allowed_chars) for i in range(length)])",
      "lines_of_code": 18
    },
    {
      "symbol_name": "Form",
      "symbol_type": "class",
      "file_path": "django/forms/forms.py",
      "first_commit_sha": "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
      "first_commit_date": "2012-07-04T02:50:12",
      "first_commit_message": "Changed a lot of internal code to use 'format_html' where appropriate/possible",
      "original_docstring": "A collection of Fields, plus their associated data.",
      "original_source": "class Form(BaseForm):\n    \"A collection of Fields, plus their associated data.\"\n    # This is a separate class from BaseForm in order to abstract the way\n    # self.fields is specified. This class (Form) is the one that does the\n    # fancy metaclass stuff purely for the semantic sugar -- it allows one\n    # to define a form using declarative syntax.\n    # BaseForm itself has no way of designating self.fields.\n    __metaclass__ = DeclarativeFieldsMetaclass",
      "lines_of_code": 8
    },
    {
      "symbol_name": "BaseForm",
      "symbol_type": "class",
      "file_path": "django/forms/forms.py",
      "first_commit_sha": "a92e7f37c4ae84b6b8d8016cc6783211e9047219",
      "first_commit_date": "2012-07-04T02:50:12",
      "first_commit_message": "Changed a lot of internal code to use 'format_html' where appropriate/possible",
      "original_docstring": null,
      "original_source": "class BaseForm(StrAndUnicode):\n    # This is the main implementation of all the Form logic. Note that this\n    # class is different than Form. See the comments by the Form class for more\n    # information. Any improvements to the form API should be made to *this*\n    # class, not to the Form class.\n    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,\n                 initial=None, error_class=ErrorList, label_suffix=':',\n                 empty_permitted=False):\n        self.is_bound = data is not None or files is not None\n        self.data = data or {}\n        self.files = files or {}\n        self.auto_id = auto_id\n        self.prefix = prefix\n        self.initial = initial or {}\n        self.error_class = error_class\n        self.label_suffix = label_suffix\n        self.empty_permitted = empty_permitted\n        self._errors = None # Stores the errors after clean() has been called.\n        self._changed_data = None\n\n        # The base_fields class attribute is the *class-wide* definition of\n        # fields. Because a particular *instance* of the class might want to\n        # alter self.fields, we create self.fields here by copying base_fields.\n        # Instances should always modify self.fields; they should not modify\n        # self.base_fields.\n        self.fields = copy.deepcopy(self.base_fields)\n\n    def __unicode__(self):\n        return self.as_table()\n\n    def __iter__(self):\n        for name in self.fields:\n            yield self[name]\n\n    def __getitem__(self, name):\n        \"Returns a BoundField with the given name.\"\n        try:\n            field = self.fields[name]\n        except KeyError:\n            raise KeyError('Key %r not found in Form' % name)\n        return BoundField(self, field, name)\n\n    def _get_errors(self):\n        \"Returns an ErrorDict for the data provided for the form\"\n        if self._errors is None:\n            self.full_clean()\n        return self._errors\n    errors = property(_get_errors)\n\n    def is_valid(self):\n        \"\"\"\n        Returns True if the form has no errors. Otherwise, False. If errors are\n        being ignored, returns False.\n        \"\"\"\n        return self.is_bound and not bool(self.errors)\n\n    def add_prefix(self, field_name):\n        \"\"\"\n        Returns the field name with a prefix appended, if this Form has a\n        prefix set.\n\n        Subclasses may wish to override.\n        \"\"\"\n        return self.prefix and ('%s-%s' % (self.prefix, field_name)) or field_name\n\n    def add_initial_prefix(self, field_name):\n        \"\"\"\n        Add a 'initial' prefix for checking dynamic initial values\n        \"\"\"\n        return 'initial-%s' % self.add_prefix(field_name)\n\n    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):\n        \"Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().\"\n        top_errors = self.non_field_errors() # Errors that should be displayed above all fields.\n        output, hidden_fields = [], []\n\n        for name, field in self.fields.items():\n            html_class_attr = ''\n            bf = self[name]\n            bf_errors = self.error_class([conditional_escape(error) for error in bf.errors]) # Escape and cache in local variable.\n            if bf.is_hidden:\n                if bf_errors:\n                    top_errors.extend(['(Hidden field %s) %s' % (name, force_unicode(e)) for e in bf_errors])\n                hidden_fields.append(unicode(bf))\n            else:\n                # Create a 'class=\"...\"' atribute if the row should have any\n                # CSS classes applied.\n                css_classes = bf.css_classes()\n                if css_classes:\n                    html_class_attr = ' class=\"%s\"' % css_classes\n\n                if errors_on_separate_row and bf_errors:\n                    output.append(error_row % force_unicode(bf_errors))\n\n                if bf.label:\n                    label = conditional_escape(force_unicode(bf.label))\n                    # Only add the suffix if the label does not end in\n                    # punctuation.\n                    if self.label_suffix:\n                        if label[-1] not in ':?.!':\n                            label = format_html('{}{}', label, self.label_suffix)\n                    label = bf.label_tag(label) or ''\n                else:\n                    label = ''\n\n                if field.help_text:\n                    help_text = help_text_html % force_unicode(field.help_text)\n                else:\n                    help_text = ''\n\n                output.append(normal_row % {\n                    'errors': force_unicode(bf_errors),\n                    'label': force_unicode(label),\n                    'field': unicode(bf),\n                    'help_text': help_text,\n                    'html_class_attr': html_class_attr\n                })\n\n        if top_errors:\n            output.insert(0, error_row % force_unicode(top_errors))\n\n        if hidden_fields: # Insert any hidden fields in the last row.\n            str_hidden = ''.join(hidden_fields)\n            if output:\n                last_row = output[-1]\n                # Chop off the trailing row_ender (e.g. '</td></tr>') and\n                # insert the hidden fields.\n                if not last_row.endswith(row_ender):\n                    # This can happen in the as_p() case (and possibly others\n                    # that users write): if there are only top errors, we may\n                    # not be able to conscript the last row for our purposes,\n                    # so insert a new, empty row.\n                    last_row = (normal_row % {'errors': '', 'label': '',\n                                              'field': '', 'help_text':'',\n                                              'html_class_attr': html_class_attr})\n                    output.append(last_row)\n                output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender\n            else:\n                # If there aren't any rows in the output, just append the\n                # hidden fields.\n                output.append(str_hidden)\n        return mark_safe('\\n'.join(output))\n\n    def as_table(self):\n        \"Returns this form rendered as HTML <tr>s -- excluding the <table></table>.\"\n        return self._html_output(\n            normal_row = '<tr%(html_class_attr)s><th>%(label)s</th><td>%(errors)s%(field)s%(help_text)s</td></tr>',\n            error_row = '<tr><td colspan=\"2\">%s</td></tr>',\n            row_ender = '</td></tr>',\n            help_text_html = '<br /><span class=\"helptext\">%s</span>',\n            errors_on_separate_row = False)\n\n    def as_ul(self):\n        \"Returns this form rendered as HTML <li>s -- excluding the <ul></ul>.\"\n        return self._html_output(\n            normal_row = '<li%(html_class_attr)s>%(errors)s%(label)s %(field)s%(help_text)s</li>',\n            error_row = '<li>%s</li>',\n            row_ender = '</li>',\n            help_text_html = ' <span class=\"helptext\">%s</span>',\n            errors_on_separate_row = False)\n\n    def as_p(self):\n        \"Returns this form rendered as HTML <p>s.\"\n        return self._html_output(\n            normal_row = '<p%(html_class_attr)s>%(label)s %(field)s%(help_text)s</p>',\n            error_row = '%s',\n            row_ender = '</p>',\n            help_text_html = ' <span class=\"helptext\">%s</span>',\n            errors_on_separate_row = True)\n\n    def non_field_errors(self):\n        \"\"\"\n        Returns an ErrorList of errors that aren't associated with a particular\n        field -- i.e., from Form.clean(). Returns an empty ErrorList if there\n        are none.\n        \"\"\"\n        return self.errors.get(NON_FIELD_ERRORS, self.error_class())\n\n    def _raw_value(self, fieldname):\n        \"\"\"\n        Returns the raw_value for a particular field name. This is just a\n        convenient wrapper around widget.value_from_datadict.\n        \"\"\"\n        field = self.fields[fieldname]\n        prefix = self.add_prefix(fieldname)\n        return field.widget.value_from_datadict(self.data, self.files, prefix)\n\n    def full_clean(self):\n        \"\"\"\n        Cleans all of self.data and populates self._errors and\n        self.cleaned_data.\n        \"\"\"\n        self._errors = ErrorDict()\n        if not self.is_bound: # Stop further processing.\n            return\n        self.cleaned_data = {}\n        # If the form is permitted to be empty, and none of the form data has\n        # changed from the initial data, short circuit any validation.\n        if self.empty_permitted and not self.has_changed():\n            return\n        self._clean_fields()\n        self._clean_form()\n        self._post_clean()\n        if self._errors:\n            del self.cleaned_data\n\n    def _clean_fields(self):\n        for name, field in self.fields.items():\n            # value_from_datadict() gets the data from the data dictionaries.\n            # Each widget type knows how to retrieve its own data, because some\n            # widgets split data over several HTML fields.\n            value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name))\n            try:\n                if isinstance(field, FileField):\n                    initial = self.initial.get(name, field.initial)\n                    value = field.clean(value, initial)\n                else:\n                    value = field.clean(value)\n                self.cleaned_data[name] = value\n                if hasattr(self, 'clean_%s' % name):\n                    value = getattr(self, 'clean_%s' % name)()\n                    self.cleaned_data[name] = value\n            except ValidationError as e:\n                self._errors[name] = self.error_class(e.messages)\n                if name in self.cleaned_data:\n                    del self.cleaned_data[name]\n\n    def _clean_form(self):\n        try:\n            self.cleaned_data = self.clean()\n        except ValidationError as e:\n            self._errors[NON_FIELD_ERRORS] = self.error_class(e.messages)\n\n    def _post_clean(self):\n        \"\"\"\n        An internal hook for performing additional cleaning after form cleaning\n        is complete. Used for model validation in model forms.\n        \"\"\"\n        pass\n\n    def clean(self):\n        \"\"\"\n        Hook for doing any extra form-wide cleaning after Field.clean() been\n        called on every field. Any ValidationError raised by this method will\n        not be associated with a particular field; it will have a special-case\n        association with the field named '__all__'.\n        \"\"\"\n        return self.cleaned_data\n\n    def has_changed(self):\n        \"\"\"\n        Returns True if data differs from initial.\n        \"\"\"\n        return bool(self.changed_data)\n\n    def _get_changed_data(self):\n        if self._changed_data is None:\n            self._changed_data = []\n            # XXX: For now we're asking the individual widgets whether or not the\n            # data has changed. It would probably be more efficient to hash the\n            # initial data, store it in a hidden field, and compare a hash of the\n            # submitted data, but we'd need a way to easily get the string value\n            # for a given field. Right now, that logic is embedded in the render\n            # method of each widget.\n            for name, field in self.fields.items():\n                prefixed_name = self.add_prefix(name)\n                data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n                if not field.show_hidden_initial:\n                    initial_value = self.initial.get(name, field.initial)\n                else:\n                    initial_prefixed_name = self.add_initial_prefix(name)\n                    hidden_widget = field.hidden_widget()\n                    initial_value = hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name)\n                if field.widget._has_changed(initial_value, data_value):\n                    self._changed_data.append(name)\n        return self._changed_data\n    changed_data = property(_get_changed_data)\n\n    def _get_media(self):\n        \"\"\"\n        Provide a description of all media required to render the widgets on this form\n        \"\"\"\n        media = Media()\n        for field in self.fields.values():\n            media = media + field.widget.media\n        return media\n    media = property(_get_media)\n\n    def is_multipart(self):\n        \"\"\"\n        Returns True if the form needs to be multipart-encoded, i.e. it has\n        FileInput. Otherwise, False.\n        \"\"\"\n        for field in self.fields.values():\n            if field.widget.needs_multipart_form:\n                return True\n        return False\n\n    def hidden_fields(self):\n        \"\"\"\n        Returns a list of all the BoundField objects that are hidden fields.\n        Useful for manual form layout in templates.\n        \"\"\"\n        return [field for field in self if field.is_hidden]\n\n    def visible_fields(self):\n        \"\"\"\n        Returns a list of BoundField objects that aren't hidden fields.\n        The opposite of the hidden_fields() method.\n        \"\"\"\n        return [field for field in self if not field.is_hidden]",
      "lines_of_code": 312
    },
    {
      "symbol_name": "ModelForm",
      "symbol_type": "class",
      "file_path": "django/forms/models.py",
      "first_commit_sha": "29f0e8182f49e2927ae46e748d09d0672d4fc127",
      "first_commit_date": "2008-07-22T08:54:09",
      "first_commit_message": "Fixed #7847 -- Removed a whole bunch of unused imports from throughout the codebase. Thanks, julien\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@8046 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
      "original_docstring": null,
      "original_source": "class ModelForm(BaseModelForm):\n    __metaclass__ = ModelFormMetaclass",
      "lines_of_code": 2
    },
    {
      "symbol_name": "Manager",
      "symbol_type": "class",
      "file_path": "django/db/models/manager.py",
      "first_commit_sha": "5ceed0a05388079118319940acdb2abe4ee01de6",
      "first_commit_date": "2010-01-11T00:06:20",
      "first_commit_message": "Changed a whole bunch of places to raise exception instances instead of old-style raising exception classes plus a comma. Good for the future Python 3 conversion\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@12180 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
      "original_docstring": null,
      "original_source": "class Manager(object):\n    # Tracks each time a Manager instance is created. Used to retain order.\n    creation_counter = 0\n\n    def __init__(self):\n        super(Manager, self).__init__()\n        self._set_creation_counter()\n        self.model = None\n        self._inherited = False\n        self._db = None\n\n    def contribute_to_class(self, model, name):\n        # TODO: Use weakref because of possible memory leak / circular reference.\n        self.model = model\n        setattr(model, name, ManagerDescriptor(self))\n        if not getattr(model, '_default_manager', None) or self.creation_counter < model._default_manager.creation_counter:\n            model._default_manager = self\n        if model._meta.abstract or (self._inherited and not self.model._meta.proxy):\n            model._meta.abstract_managers.append((self.creation_counter, name,\n                    self))\n        else:\n            model._meta.concrete_managers.append((self.creation_counter, name,\n                self))\n\n    def _set_creation_counter(self):\n        \"\"\"\n        Sets the creation counter value for this instance and increments the\n        class-level copy.\n        \"\"\"\n        self.creation_counter = Manager.creation_counter\n        Manager.creation_counter += 1\n\n    def _copy_to_model(self, model):\n        \"\"\"\n        Makes a copy of the manager and assigns it to 'model', which should be\n        a child of the existing model (used when inheriting a manager from an\n        abstract base class).\n        \"\"\"\n        assert issubclass(model, self.model)\n        mgr = copy.copy(self)\n        mgr._set_creation_counter()\n        mgr.model = model\n        mgr._inherited = True\n        return mgr\n\n    def db_manager(self, alias):\n        obj = copy.copy(self)\n        obj._db = alias\n        return obj\n\n    @property\n    def db(self):\n        return self._db or DEFAULT_DB_ALIAS\n\n    #######################\n    # PROXIES TO QUERYSET #\n    #######################\n\n    def get_empty_query_set(self):\n        return EmptyQuerySet(self.model)\n\n    def get_query_set(self):\n        \"\"\"Returns a new QuerySet object.  Subclasses can override this method\n        to easily customize the behavior of the Manager.\n        \"\"\"\n        qs = QuerySet(self.model)\n        if self._db is not None:\n            qs = qs.using(self._db)\n        return qs\n\n    def none(self):\n        return self.get_empty_query_set()\n\n    def all(self):\n        return self.get_query_set()\n\n    def count(self):\n        return self.get_query_set().count()\n\n    def dates(self, *args, **kwargs):\n        return self.get_query_set().dates(*args, **kwargs)\n\n    def distinct(self, *args, **kwargs):\n        return self.get_query_set().distinct(*args, **kwargs)\n\n    def extra(self, *args, **kwargs):\n        return self.get_query_set().extra(*args, **kwargs)\n\n    def get(self, *args, **kwargs):\n        return self.get_query_set().get(*args, **kwargs)\n\n    def get_or_create(self, **kwargs):\n        return self.get_query_set().get_or_create(**kwargs)\n\n    def create(self, **kwargs):\n        return self.get_query_set().create(**kwargs)\n\n    def filter(self, *args, **kwargs):\n        return self.get_query_set().filter(*args, **kwargs)\n\n    def aggregate(self, *args, **kwargs):\n        return self.get_query_set().aggregate(*args, **kwargs)\n\n    def annotate(self, *args, **kwargs):\n        return self.get_query_set().annotate(*args, **kwargs)\n\n    def complex_filter(self, *args, **kwargs):\n        return self.get_query_set().complex_filter(*args, **kwargs)\n\n    def exclude(self, *args, **kwargs):\n        return self.get_query_set().exclude(*args, **kwargs)\n\n    def in_bulk(self, *args, **kwargs):\n        return self.get_query_set().in_bulk(*args, **kwargs)\n\n    def iterator(self, *args, **kwargs):\n        return self.get_query_set().iterator(*args, **kwargs)\n\n    def latest(self, *args, **kwargs):\n        return self.get_query_set().latest(*args, **kwargs)\n\n    def order_by(self, *args, **kwargs):\n        return self.get_query_set().order_by(*args, **kwargs)\n\n    def select_related(self, *args, **kwargs):\n        return self.get_query_set().select_related(*args, **kwargs)\n\n    def values(self, *args, **kwargs):\n        return self.get_query_set().values(*args, **kwargs)\n\n    def values_list(self, *args, **kwargs):\n        return self.get_query_set().values_list(*args, **kwargs)\n\n    def update(self, *args, **kwargs):\n        return self.get_query_set().update(*args, **kwargs)\n\n    def reverse(self, *args, **kwargs):\n        return self.get_query_set().reverse(*args, **kwargs)\n\n    def defer(self, *args, **kwargs):\n        return self.get_query_set().defer(*args, **kwargs)\n\n    def only(self, *args, **kwargs):\n        return self.get_query_set().only(*args, **kwargs)\n\n    def using(self, *args, **kwargs):\n        return self.get_query_set().using(*args, **kwargs)\n\n    def exists(self, *args, **kwargs):\n        return self.get_query_set().exists(*args, **kwargs)\n\n    def _insert(self, values, **kwargs):\n        return insert_query(self.model, values, **kwargs)\n\n    def _update(self, values, **kwargs):\n        return self.get_query_set()._update(values, **kwargs)\n\n    def raw(self, raw_query, params=None, *args, **kwargs):\n        return RawQuerySet(raw_query=raw_query, model=self.model, params=params, using=self.db, *args, **kwargs)",
      "lines_of_code": 159
    },
    {
      "symbol_name": "BaseManager",
      "symbol_type": "class",
      "file_path": "django/db/models/manager.py",
      "first_commit_sha": "31fadc120213284da76801cc7bc56e9f32d7281b",
      "first_commit_date": "2013-07-26T15:11:27",
      "first_commit_message": "Fixed #20625 -- Chainable Manager/QuerySet methods.\n\nAdditionally this patch solves the orthogonal problem that specialized\n`QuerySet` like `ValuesQuerySet` didn't inherit from the current `QuerySet`\ntype. This wasn't an issue until now because we didn't officially support\ncustom `QuerySet` but it became necessary with the introduction of this new\nfeature.\n\nThanks aaugustin, akaariai, carljm, charettes, mjtamlyn, shaib and timgraham\nfor the reviews.",
      "original_docstring": null,
      "original_source": "class BaseManager(six.with_metaclass(RenameManagerMethods)):\n    # Tracks each time a Manager instance is created. Used to retain order.\n    creation_counter = 0\n\n    def __init__(self):\n        super(BaseManager, self).__init__()\n        self._set_creation_counter()\n        self.model = None\n        self._inherited = False\n        self._db = None\n\n    @classmethod\n    def _get_queryset_methods(cls, queryset_class):\n        def create_method(name, method):\n            def manager_method(self, *args, **kwargs):\n                return getattr(self.get_queryset(), name)(*args, **kwargs)\n            manager_method.__name__ = method.__name__\n            manager_method.__doc__ = method.__doc__\n            return manager_method\n\n        new_methods = {}\n        # Refs http://bugs.python.org/issue1785.\n        predicate = inspect.isfunction if six.PY3 else inspect.ismethod\n        for name, method in inspect.getmembers(queryset_class, predicate=predicate):\n            # Only copy missing methods.\n            if hasattr(cls, name):\n                continue\n            # Only copy public methods or methods with the attribute `queryset_only=False`.\n            queryset_only = getattr(method, 'queryset_only', None)\n            if queryset_only or (queryset_only is None and name.startswith('_')):\n                continue\n            # Copy the method onto the manager.\n            new_methods[name] = create_method(name, method)\n        return new_methods\n\n    @classmethod\n    def from_queryset(cls, queryset_class, class_name=None):\n        if class_name is None:\n            class_name = '%sFrom%s' % (cls.__name__, queryset_class.__name__)\n        class_dict = {\n            '_queryset_class': queryset_class,\n        }\n        class_dict.update(cls._get_queryset_methods(queryset_class))\n        return type(class_name, (cls,), class_dict)\n\n    def contribute_to_class(self, model, name):\n        # TODO: Use weakref because of possible memory leak / circular reference.\n        self.model = model\n        # Only contribute the manager if the model is concrete\n        if model._meta.abstract:\n            setattr(model, name, AbstractManagerDescriptor(model))\n        elif model._meta.swapped:\n            setattr(model, name, SwappedManagerDescriptor(model))\n        else:\n        # if not model._meta.abstract and not model._meta.swapped:\n            setattr(model, name, ManagerDescriptor(self))\n        if not getattr(model, '_default_manager', None) or self.creation_counter < model._default_manager.creation_counter:\n            model._default_manager = self\n        if model._meta.abstract or (self._inherited and not self.model._meta.proxy):\n            model._meta.abstract_managers.append((self.creation_counter, name,\n                    self))\n        else:\n            model._meta.concrete_managers.append((self.creation_counter, name,\n                self))\n\n    def _set_creation_counter(self):\n        \"\"\"\n        Sets the creation counter value for this instance and increments the\n        class-level copy.\n        \"\"\"\n        self.creation_counter = BaseManager.creation_counter\n        BaseManager.creation_counter += 1\n\n    def _copy_to_model(self, model):\n        \"\"\"\n        Makes a copy of the manager and assigns it to 'model', which should be\n        a child of the existing model (used when inheriting a manager from an\n        abstract base class).\n        \"\"\"\n        assert issubclass(model, self.model)\n        mgr = copy.copy(self)\n        mgr._set_creation_counter()\n        mgr.model = model\n        mgr._inherited = True\n        return mgr\n\n    def db_manager(self, using):\n        obj = copy.copy(self)\n        obj._db = using\n        return obj\n\n    @property\n    def db(self):\n        return self._db or router.db_for_read(self.model)\n\n    def get_queryset(self):\n        \"\"\"\n        Returns a new QuerySet object.  Subclasses can override this method to\n        easily customize the behavior of the Manager.\n        \"\"\"\n        return self._queryset_class(self.model, using=self._db)\n\n    def all(self):\n        # We can't proxy this method through the `QuerySet` like we do for the\n        # rest of the `QuerySet` methods. This is because `QuerySet.all()`\n        # works by creating a \"copy\" of the current queryset and in making said\n        # copy, all the cached `prefetch_related` lookups are lost. See the\n        # implementation of `RelatedManager.get_queryset()` for a better\n        # understanding of how this comes into play.\n        return self.get_queryset()\n\n    def _insert(self, objs, fields, **kwargs):\n        return insert_query(self.model, objs, fields, **kwargs)\n\n    def raw(self, raw_query, params=None, *args, **kwargs):\n        return RawQuerySet(raw_query=raw_query, model=self.model, params=params, using=self._db, *args, **kwargs)",
      "lines_of_code": 116
    }
  ]
}